# pandas의 Series()와 DataFrame()으로 생성된 데이터 끼리는 사칙연산이 가능
# Series()로 생성한 데이터의 예
import pandas as pd

s1 = pd.Series([1,2,3,4,5])
s2 = pd.Series([10, 20, 30, 40, 50])
print(s1 + s2)
# 0    11
# 1    22
# 2    33
# 3    44
# 4    55
# dtype: int64

print(s2-s1)
# 0     9
# 1    18
# 2    27
# 3    36
# 4    45
# dtype: int64

print(s1 * s2)
# 0     10
# 1     40
# 2     90
# 3    160
# 4    250
# dtype: int64

print(s2/s1)
# 0    10.0
# 1    10.0
# 2    10.0
# 3    10.0
# 4    10.0
# dtype: float64

# 파이썬의 리스트와 numpy의 배열과 달리 pandas의 데이터 끼리는 서로 크기가 달라도 연산이 가능
# 이 경우 연산을 할 수 있는 항목과 연산을 수행
s3 = pd.Series([1,2,3,4])
s4 = pd.Series([10, 20, 30, 40, 50])
print(s3 + s4)
# 0    11.0
# 1    22.0
# 2    33.0
# 3    44.0
# 4     NaN
# dtype: float64

print(s4-s3)
# 0     9.0
# 1    18.0
# 2    27.0
# 3    36.0
# 4     NaN
# dtype: float64

print(s3 * s4)
# 0     10.0
# 1     40.0
# 2     90.0
# 3    160.0
# 4      NaN
# dtype: float64

print(s4/s3)
# 0    10.0
# 1    10.0
# 2    10.0
# 3    10.0
# 4     NaN
# dtype: float64

# s3와 s4의 데이터 크기가 달라서, 연산할 수 있는 부분만 연산한 결과를 보여주고 연산할 수 없는 부분은 NaN으로 표시

# DataFrame()으로 생성한 데이터의 예
table_data1 = {'A': [1,2,3,4,5],
               'B': [10,20,30,40,50],
               'C': [100,200,300,400,500]}
df1 = pd.DataFrame(table_data1)
print(df1)
#    A   B    C
# 0  1  10  100
# 1  2  20  200
# 2  3  30  300
# 3  4  40  400
# 4  5  50  500

table_data2 = {'A': [6,7,8],
               'B': [60, 70, 80],
               'C': [600, 700, 800]}
df2 = pd.DataFrame(table_data2)
print(df2)
#    A   B    C
# 0  6  60  600
# 1  7  70  700
# 2  8  80  800

# 두 개의 DataFrame 데이터 df1과 df2는 길이가 같지 않음
# 길이가 같지 않더라도 연산이 가능
print(df1 + df2)
#       A      B       C
# 0   7.0   70.0   700.0
# 1   9.0   90.0   900.0
# 2  11.0  110.0  1100.0
# 3   NaN    NaN     NaN
# 4   NaN    NaN     NaN

# Series와 마찬가지로 DataFrame도 연산할 수 있는 항목 끼리만 연산하고 그렇지 못한 항목은 NaN으로 표시
# 공간은 차지하되 데이터는 없는 상태

# pandas에는 데이터의 통계 분석을 위한 다양한 메서드가 있어서 데이터의 총합, 평균, 표준 편차들을 쉽게 구할 수 있음
# 2012년 부터 2016년 까지 우리나라의 계절별 강수량(단위 mm).
table_data3 = {'봄': [256.5, 264.3, 215.9, 223.2, 312.8],
               '여름': [770.6, 567.5, 599.8, 387.1, 446.2],
               '가을': [363.5, 231.2, 293.1, 247.7, 381.6],
               '겨울': [139.3, 59.9, 76.9, 109.1, 108.1]}
columns_list = ['봄', '여름', '가을', '겨울']
index_list = ['2012', '2013', '2014','2015','2016']
df3 = pd.DataFrame(index = index_list, columns=columns_list, data = table_data3)
print(df3)
#           봄     여름     가을     겨울
# 2012  256.5  770.6  363.5  139.3
# 2013  264.3  567.5  231.2   59.9
# 2014  215.9  599.8  293.1   76.9
# 2015  223.2  387.1  247.7  109.1
# 2016  312.8  446.2  381.6  108.1

# pandas에서 제공하는 통계 메서드는 원소의 합을 구하는 sum(), 평균을 구하는 mean(),
# 표준편차를 구하는 std(), 분산을 구하는 var(), 최솟값을 구하는 min(), 최댓값을 구하는 max(),
# 각 원소의 누적 합을 구하는 cumsum(), 각 원소의 누적 곱을 구하는 cumprod() 등이 있음
# -> numpy의 메서드 이름이 동일

print(df3.std()) # 계절별 강수량 표준편차
# 봄      38.628267
# 여름    148.888895
# 가을     67.358496
# 겨울     30.925523
# dtype: float64

# 연도별로 평균 강수량과 표준 편차를 구할 경우엔 연산의 방향 설정을 위해 axis 인자를 추가
# 인자 axis가 0이면 DataFrame의 values에서 열별로 연산을 수행하고
# 1이면 행별로 연산. axis 인자를 설정하지 ㅇ낳으면 기본값을 0으로 설정
print(df3.mean(axis=1))
# 2012    382.475
# 2013    280.725
# 2014    296.425
# 2015    241.775
# 2016    312.175
# dtype: float64

print(df3.std(axis=1))
# 2012    274.472128
# 2013    211.128782
# 2014    221.150739
# 2015    114.166760
# 2016    146.548658
# dtype: float64

# 평균과 표준편차를 개별적으로 구했으나 describe()을 이용하면
# 평균, 표준편차, 최솟값과 최댓값 등을 한 번에 구할 수 있음
# 25% / 50% / 75% : 백분위수의 각 지정으로, 분포를 반영해 평균을 보완하는 목적으로 사용
print(df3.describe())
#                 봄          여름          가을          겨울
# count    5.000000    5.000000    5.000000    5.000000
# mean   254.540000  554.240000  303.420000   98.660000
# std     38.628267  148.888895   67.358496   30.925523
# min    215.900000  387.100000  231.200000   59.900000
# 25%    223.200000  446.200000  247.700000   76.900000
# 50%    256.500000  567.500000  293.100000  108.100000
# 75%    264.300000  599.800000  363.500000  109.100000
# max    312.800000  770.600000  381.600000  139.300000






















